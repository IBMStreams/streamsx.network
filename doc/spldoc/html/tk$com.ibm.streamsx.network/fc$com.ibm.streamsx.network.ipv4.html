<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE html
  PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xml:lang="en-us" lang="en-us">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
<meta name="copyright" content="(C) Copyright 2005"/>
<meta name="DC.rights.owner" content="(C) Copyright 2005"/>
<meta name="DC.Type" content="reference"/>
<meta name="DC.Title" content="C++ Native Functions: com.ibm.streamsx.network.ipv4"/>
<meta name="DC.Format" content="XHTML"/>
<meta name="DC.Identifier" content="spldoc_functions"/>
<link rel="stylesheet" type="text/css" href="../../html/commonltr.css"/>
<link rel="stylesheet" type="text/css" href="../../html/spldoc.css"/>
<title>C++ Native Functions: com.ibm.streamsx.network.ipv4</title>
</head>
<body id="spldoc_functions">


<h1 class="title topictitle1">C++ Native Functions: <tt class="ph tt">com.ibm.streamsx.network.ipv4</tt></h1>

<div class="body refbody">
<div class="section">
<p class="p">
<a class="xref" href="../toolkits/toolkits.html">Toolkits</a> &gt; <a class="xref" href="tk$com.ibm.streamsx.network.html">com.ibm.streamsx.network 3.0.0</a> &gt; <a class="xref" href="ns$com.ibm.streamsx.network.ipv4.html">com.ibm.streamsx.network.ipv4</a> &gt; C++ Native Functions</p>

</div>

<div class="section">
This page documents native functions that can be invoked from SPL, including the SPL interfaces that can be used to invoke each of the native functions.
</div>

<div class="section">
<p class="p splhead-1"><strong class="ph b"><a class="xref" href="../references/FunctionModel.html#spldoc_reference_function_model____functionset">Function Set</a></strong></p>
<dl class="dl">
  <dt class="dt dlterm"><a class="xref" href="../references/FunctionModel.html#spldoc_reference_function_model__functionset__headerfilename">Header File</a>  </dt>

  <dd class="dd"> IPv4AddressFunctions.h  </dd>

</dl>

<dl class="dl">
  <dt class="dt dlterm"><a class="xref" href="../references/FunctionModel.html#spldoc_reference_function_model__functionset__cppnamespacename">CPP Namespace Name</a>  </dt>

  <dd class="dd"> com::ibm::streamsx::network::ipv4  </dd>

</dl>

<dl class="dl">
  <dt class="dt dlterm"><a class="xref" href="../references/FunctionModel.html#spldoc_reference_function_model__functionset__dependencies"><strong class="ph b">Dependencies</strong></a>  </dt>

  <dd class="dd">
    <dl class="dl">
      
         <dt class="dt dlterm">         </dt>

          <dd class="dd"/>
      <dd class="dd"><a class="xref" href="../references/FunctionModel.html#spldoc_reference_function_model__functionset__dependencies__managedlibrary_includePath">Include paths</a>: <tt class="ph tt">../../impl/include/</tt>      </dd>

      
 </dl>
</dd>

</dl>

</div>

<div class="section">
<p class="p splhead-1"><strong class="ph b"><a class="xref" href="../references/FunctionModel.html#spldoc_reference_function_model__functionset__functions">Functions</a></strong></p>
<dl class="dl" compact="compact">
 
   <dt class="dt dlterm splpart" id="spldoc_functions__compare.rstring.rstring"><tt class="ph tt">      public int32 compare(rstring ip1, rstring ip2)      </tt>   </dt>

   <dd class="dd">
<p class="p">Returns <tt class="ph tt">-1</tt> if <em class="ph i">ip1</em> is less than <em class="ph i">ip2</em>. Returns <tt class="ph tt">0</tt> if <em class="ph i">ip1</em> is equal to <em class="ph i">ip2</em>. Returns <tt class="ph tt">1</tt> if <em class="ph i">ip1</em> is greater than <em class="ph i">ip2</em>. Both <em class="ph i">ip1</em> and <em class="ph i">ip2</em> must be valid IPv4 addresses, otherwise returns a value of <tt class="ph tt">-2</tt>.
</p>

   </dd>

 
 
   <dt class="dt dlterm splpart" id="spldoc_functions__convertHostnameToIPV4AddressNumeric.rstring"><tt class="ph tt">      public uint32 convertHostnameToIPV4AddressNumeric(rstring hostname)      </tt>   </dt>

   <dd class="dd">
<p class="p">This function converts a hostname into a binary IPv4 address. If no address can be found for the hostname, zero is returned.
</p>

   </dd>

 
 
   <dt class="dt dlterm splpart" id="spldoc_functions__convertHostnameToIPV4AddressString.rstring"><tt class="ph tt">      public rstring convertHostnameToIPV4AddressString(rstring hostname)      </tt>   </dt>

   <dd class="dd">
<p class="p">This function converts a hostname into a string representation of an IPv4 address. If no address can be found for the hostname, an empty string is returned.
</p>

   </dd>

 
 
   <dt class="dt dlterm splpart" id="spldoc_functions__convertIPV4AddressNumericToHostname.uint32"><tt class="ph tt">      public rstring convertIPV4AddressNumericToHostname(uint32 ip4AddressNumeric)      </tt>   </dt>

   <dd class="dd">
<p class="p">This function converts a four-byte binary representation of an IPv4 address into a hostname. If no hostname can be found for the address, an empty string is returned.
</p>

   </dd>

 
 
   <dt class="dt dlterm splpart" id="spldoc_functions__convertIPV4AddressNumericToString.uint32"><tt class="ph tt">      public rstring convertIPV4AddressNumericToString(uint32 ip4AddressNumeric)      </tt>   </dt>

   <dd class="dd">
<p class="p">This function converts a four-byte binary representation of an IPv4 address into a string representation.
</p>

   </dd>

 
 
   <dt class="dt dlterm splpart" id="spldoc_functions__convertIPV4AddressNumericToSubnet.uint32.int32"><tt class="ph tt">      public uint32 convertIPV4AddressNumericToSubnet(uint32 ipAddress, int32 maskbits)      </tt>   </dt>

   <dd class="dd">
<p class="p">This function converts a four-byte binary representation of an IPv4 address into a four-byte binary subnet address, using the specified number of mask bits.
</p>

   </dd>

 
 
   <dt class="dt dlterm splpart" id="spldoc_functions__convertIPV4AddressStringToHostname.rstring"><tt class="ph tt">      public rstring convertIPV4AddressStringToHostname(rstring ipAddress)      </tt>   </dt>

   <dd class="dd">
<p class="p">This function converts a string containing an IPv4 address into a domain name, if the address has one. If not, the IP address is returned.
</p>

   </dd>

 
 
   <dt class="dt dlterm splpart" id="spldoc_functions__convertIPV4AddressStringToNumeric.rstring"><tt class="ph tt">      public uint32 convertIPV4AddressStringToNumeric(rstring ip4AddressString)      </tt>   </dt>

   <dd class="dd">
<p class="p">This function converts a string representation of an IPv4 address to a four-byte binary representation. If the string does not represent a valid IPv4 address, zero is returned.
</p>

   </dd>

 
 
   <dt class="dt dlterm splpart" id="spldoc_functions__convertIPV4AddressStringToSubnet.rstring.int32"><tt class="ph tt">      public rstring convertIPV4AddressStringToSubnet(rstring ipAddress, int32 maskbits)      </tt>   </dt>

   <dd class="dd">
<p class="p">This function converts a string representing an IPv4 address into a string representation of the subnet address, using the specified number of mask bits. If the string does not represent a valid IPv4 address, or the count is negative, zero is returned.
</p>

   </dd>

 
 
   <dt class="dt dlterm splpart" id="spldoc_functions__getAllAddressesInNetwork.rstring"><tt class="ph tt">      public list&lt;rstring&gt; getAllAddressesInNetwork(rstring networkCIDR)      </tt>   </dt>

   <dd class="dd">
<p class="p">Returns a list of all IP addresses in the network. The <em class="ph i">networkCIDR</em> argument must be in CIDR format (i.e. 0.0.0.0/24), otherwise an empty list will be returned.
</p>

   </dd>

 
 
   <dt class="dt dlterm splpart" id="spldoc_functions__isEqualTo.rstring.rstring"><tt class="ph tt">      public boolean isEqualTo(rstring ip1, rstring ip2)      </tt>   </dt>

   <dd class="dd">
<p class="p">Returns <tt class="ph tt">true</tt> if <em class="ph i">ip1</em> and <em class="ph i">ip2</em> are valid IPv4 addresses and <em class="ph i">ip1</em> address is equal to <em class="ph i">ip2</em> address. Otherwise returns <tt class="ph tt">false</tt>. 
</p>

   </dd>

 
 
   <dt class="dt dlterm splpart" id="spldoc_functions__isGlobal.rstring"><tt class="ph tt">      public boolean isGlobal(rstring ip)      </tt>   </dt>

   <dd class="dd">
<p class="p">Returns <tt class="ph tt">true</tt> if a valid IPv4 address was provided and the IP address is not a reserved address. Also returns <tt class="ph tt">true</tt> if the IP address is a "6to4 Relay Anycast" address, since these can be globally routed (RFC6890). In all other cases, will return <tt class="ph tt">false</tt>.
</p>

   </dd>

 
 
   <dt class="dt dlterm splpart" id="spldoc_functions__isGreaterThan.rstring.rstring"><tt class="ph tt">      public boolean isGreaterThan(rstring ip1, rstring ip2)      </tt>   </dt>

   <dd class="dd">
<p class="p">Returns <tt class="ph tt">true</tt> if <em class="ph i">ip1</em> and <em class="ph i">ip2</em> are valid IPv4 addresses and <em class="ph i">ip1</em> address is greater than <em class="ph i">ip2</em> address. Otherwise returns <tt class="ph tt">false</tt>. 
</p>

   </dd>

 
 
   <dt class="dt dlterm splpart" id="spldoc_functions__isIPV4Address.rstring"><tt class="ph tt">      public boolean isIPV4Address(rstring value)      </tt>   </dt>

   <dd class="dd">
<p class="p">Returns <tt class="ph tt">true</tt> if the <em class="ph i">value</em> parameter contains a valid IPv4 address in dotted-decimal notation (i.e 0.0.0.0), otherwise returns <tt class="ph tt">false</tt>.
</p>

   </dd>

 
 
   <dt class="dt dlterm splpart" id="spldoc_functions__isIPV4CIDRNotation.rstring"><tt class="ph tt">      public boolean isIPV4CIDRNotation(rstring networkCIDR)      </tt>   </dt>

   <dd class="dd">
<p class="p">Returns <tt class="ph tt">true</tt> if a the <em class="ph i">networkCIDR</em> argument contains a valid network address in CIDR format (i.e. 0.0.0.0/24). Otherwise returns <tt class="ph tt">false</tt>.
</p>

   </dd>

 
 
   <dt class="dt dlterm splpart" id="spldoc_functions__isInIPRange.rstring.rstring.rstring"><tt class="ph tt">      public boolean isInIPRange(rstring startIP, rstring endIP, rstring ip)      </tt>   </dt>

   <dd class="dd">
<p class="p">Returns <tt class="ph tt">true</tt> if <em class="ph i">startIP</em>, <em class="ph i">endIP</em> and <em class="ph i">ip</em> are valid IPv4 addresses and <em class="ph i">ip</em> falls within the range from <em class="ph i">startIP</em> (inclusive) to <em class="ph i">endIP</em> (exclusive). Otherwise returns <tt class="ph tt">false</tt>.
</p>

   </dd>

 
 
   <dt class="dt dlterm splpart" id="spldoc_functions__isInNetwork.rstring.rstring"><tt class="ph tt">      public boolean isInNetwork(rstring networkCIDR, rstring ip)      </tt>   </dt>

   <dd class="dd">
<p class="p">Return <tt class="ph tt">true</tt> if <em class="ph i">ip</em> address is in the network provided by the <em class="ph i">networkCIDR</em> argument. The <em class="ph i">networkCIDR</em> argument must be a valid network in CIDR format and the <em class="ph i">ip</em> argument must be a valid IPv4 address. Otherwise returns <tt class="ph tt">false</tt>.
</p>

   </dd>

 
 
   <dt class="dt dlterm splpart" id="spldoc_functions__isInNetwork.rstring.uint32"><tt class="ph tt">      public boolean isInNetwork(rstring networkCIDR, uint32 ip)      </tt>   </dt>

   <dd class="dd">
<p class="p">Return <tt class="ph tt">true</tt> if <em class="ph i">ip</em> address is in the network provided by the <em class="ph i">networkCIDR</em> argument. The <em class="ph i">networkCIDR</em> argument must be a valid network in CIDR format and the <em class="ph i">ip</em> argument must be a valid IPv4 address. Otherwise returns <tt class="ph tt">false</tt>.
</p>

   </dd>

 
 
   <dt class="dt dlterm splpart" id="spldoc_functions__isInNetworkList.list:.:rstring:.:.rstring"><tt class="ph tt">      public boolean isInNetworkList(list&lt;rstring&gt; networkList, rstring ip)      </tt>   </dt>

   <dd class="dd">
<p class="p">Return <tt class="ph tt">true</tt> if <em class="ph i">ip</em> address is in at least one of the networks provided by the <em class="ph i">networkList</em> argument. Each of the networks in the list must be a valid network in CIDR format format and the <em class="ph i">ip</em> argument must be a valid IPv4 address. Otherwise returns <tt class="ph tt">false</tt>.
</p>

   </dd>

 
 
   <dt class="dt dlterm splpart" id="spldoc_functions__isLessThan.rstring.rstring"><tt class="ph tt">      public boolean isLessThan(rstring ip1, rstring ip2)      </tt>   </dt>

   <dd class="dd">
<p class="p">Returns <tt class="ph tt">true</tt> if <em class="ph i">ip1</em> and <em class="ph i">ip2</em> are valid IPv4 addresses and <em class="ph i">ip1</em> address is less than <em class="ph i">ip2</em> address. Otherwise returns <tt class="ph tt">false</tt>. 
</p>

   </dd>

 
 
   <dt class="dt dlterm splpart" id="spldoc_functions__isLinkLocal.rstring"><tt class="ph tt">      public boolean isLinkLocal(rstring ip)      </tt>   </dt>

   <dd class="dd">
<p class="p">Returns <tt class="ph tt">true</tt> if a valid IPv4 address was provided and the IP address is a link local address (RFC3927). Otherwise returns <tt class="ph tt">false</tt>.
</p>

   </dd>

 
 
   <dt class="dt dlterm splpart" id="spldoc_functions__isLoopback.rstring"><tt class="ph tt">      public boolean isLoopback(rstring ip)      </tt>   </dt>

   <dd class="dd">
<p class="p">Returns <tt class="ph tt">true</tt> if a valid IPv4 address was provided and the IP address is a loopback address (RFC6890). Otherwise returns <tt class="ph tt">false</tt>.
</p>

   </dd>

 
 
   <dt class="dt dlterm splpart" id="spldoc_functions__isMulticast.rstring"><tt class="ph tt">      public boolean isMulticast(rstring ip)      </tt>   </dt>

   <dd class="dd">
<p class="p">Returns <tt class="ph tt">true</tt> if a valid IPv4 address was provided and the IP address is a multicast address (RFC5771). Otherwise returns <tt class="ph tt">false</tt>.
</p>

   </dd>

 
 
   <dt class="dt dlterm splpart" id="spldoc_functions__isNetworkOverlap.rstring.rstring"><tt class="ph tt">      public boolean isNetworkOverlap(rstring networkCIDR1, rstring networkCIDR2)      </tt>   </dt>

   <dd class="dd">
<p class="p">Returns <tt class="ph tt">true</tt> if <em class="ph i">networkCIDR1</em> and <em class="ph i">networkCIDR2</em> are valid networks in CIDR format and the networks overlap. The networks are considered to be overlapping if at least one IP address is common between the two networks. Otherwise returns <tt class="ph tt">false</tt>.
</p>

   </dd>

 
 
   <dt class="dt dlterm splpart" id="spldoc_functions__isPrivate.rstring"><tt class="ph tt">      public boolean isPrivate(rstring ip)      </tt>   </dt>

   <dd class="dd">
<p class="p">Returns <tt class="ph tt">true</tt> if a valid IPv4 address was provided and the IP address is a private address (RFC1918). Otherwise returns <tt class="ph tt">false</tt>.
</p>

   </dd>

 
 
   <dt class="dt dlterm splpart" id="spldoc_functions__isReserved.rstring"><tt class="ph tt">      public boolean isReserved(rstring ip)      </tt>   </dt>

   <dd class="dd">
<p class="p">Returns <tt class="ph tt">true</tt> if a valid IPv4 address was provided and the IP address is a reserved address (RFC1918). An IP address is considered to be reserved if it falls within within one of the special-use address ranges as defined by RFC6890. Otherwise returns <tt class="ph tt">false</tt>.
</p>

   </dd>

 
 
   <dt class="dt dlterm splpart" id="spldoc_functions__numAddressesInIPRange.rstring.rstring"><tt class="ph tt">      public uint32 numAddressesInIPRange(rstring startIP, rstring endIP)      </tt>   </dt>

   <dd class="dd">
<p class="p">Returns the number of IP addresses between <em class="ph i">ipStart</em> (inclusive) and <em class="ph i">ipEnd</em> (exclusive). Both <em class="ph i">ipStart</em> and <em class="ph i">ipEnd</em> must be valid IPv4 addresses, otherwise a value of <tt class="ph tt">0</tt> is returned.
</p>

   </dd>

 
 
   <dt class="dt dlterm splpart" id="spldoc_functions__numAddressesInNetwork.rstring"><tt class="ph tt">      public uint32 numAddressesInNetwork(rstring networkCIDR)      </tt>   </dt>

   <dd class="dd">
<p class="p">Returns the number of IP addresses contained within the network range. The <em class="ph i">networkCIDR</em> argument must be a valid network in CIDR format, otherwise a value of <tt class="ph tt">0</tt> is returned. 
</p>

   </dd>

 
</dl>

</div>

</div>


</body>
</html>