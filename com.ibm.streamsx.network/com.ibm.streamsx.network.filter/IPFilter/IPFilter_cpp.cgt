<%
## Copyright (C) 2017  International Business Machines Corporation
## All Rights Reserved
%>

/*
 * test close of current file when new filter is applied
 * test optional filename param
 * review locking
 * fix and test error handling cases
 * TODOs
 */

/* Additional includes go here */
#include <fstream>
#include <string>
#include <streams_boost/filesystem.hpp>
#include <streams_boost/tokenizer.hpp>
#include <streams_boost/token_iterator.hpp>
#include <streams_boost/algorithm/string/replace.hpp>
#include <streams_boost/algorithm/string/trim.hpp>
#include <streams_boost/algorithm/string/classification.hpp>
#include <streams_boost/lexical_cast.hpp>
#include <arpa/inet.h>

#include "NetworkResources.h"
#include "IPv4AddressFunctions.h"

#define IP_FILTER "IP_FILTER"

using namespace SPL;
using namespace std;
using namespace com::ibm::streamsx::network::ipv4;

/*
 * This code is modeled after the IPASNEnricher operator.  Future updates to add IPv6
 * support could leverage examples from that code.
 */
<%
unshift @INC, dirname($model->getContext()->getOperatorDirectory()) . "/../impl/bin";
require CodeGenX;

# These fragments of Perl code get strings from the operator's declaration
# in the SPL source code for use in generating C/C++ code for the operator's
# implementation below

# get the name of this operator's template
my $myOperatorKind = $model->getContext()->getKind();

# get Perl objects for input and output ports
my $inputPort0 = $model->getInputPortAt(0);
my $inputPort1 = $model->getInputPortAt(1);
my @outputPortList = @{ $model->getOutputPorts() };

my $inputPort1CppName = "";
my $filenameAttribute = "";
if(defined $inputPort1) {
    $inputPort1CppName = $inputPort1->getCppTupleName();
    $filenameAttribute = $inputPort1->getAttributeAt(0)->getName();
}

# get C++ expressions for getting the values of this operator's parameters
my $inputIPAttrParamCppValue = $model->getParameterByName("inputIPAttr")->getValueAt(0)->getCppExpression();
my $filterIPv4FileParam = $model->getParameterByName("filterIPv4File");

my $filterIPv4FileParamCppValue = "";
if(defined $filterIPv4FileParam) {
    $filterIPv4FileParamCppValue = $filterIPv4FileParam->getValueAt(0)->getCppExpression();
}

%>

<%SPL::CodeGen::implementationPrologue($model);%>

// Constructor
MY_OPERATOR::MY_OPERATOR() {
	ip4List_[0] = new IPList();
	ip4List_[1] = new IPList();
    ip4ListRSel_ = 0;
    ip4ListWSel_ = 0;
    newListAvail = false; 
	
	// Single threaded at this point so no mutex is needed.
	// Any file specified as a param is read & stored into ip4List_[0]
	<% if(defined $filterIPv4FileParam) {%>
		parseIPFile(<%=$filterIPv4FileParamCppValue%>);
	<%}%>

    // The next input file goes into ip4List_[1].
    ip4ListWSel_ = 1;
}

// Destructor
MY_OPERATOR::~MY_OPERATOR() {
	delete ip4List_[0];
	delete ip4List_[1];
}

// Notify port readiness
void MY_OPERATOR::allPortsReady() {
    // Notifies that all ports are ready. No tuples should be submitted before
    // this. Source operators can use this method to spawn threads.

    /*
      createThreads(1); // Create source thread
    */
}
 
// Notify pending shutdown
void MY_OPERATOR::prepareToShutdown() {
    // This is an asynchronous call
}

// Tuple processing for mutating ports
// Because this operator only filters tuples & does not modify them, this 
// function does not get called.
void MY_OPERATOR::process(Tuple & tuple, uint32_t port) {
    SPLAPPTRC(L_ERROR, "entering <%=$myOperatorKind%> process() mutating.", IP_FILTER);
    SPLAPPTRC(L_ERROR, "leaving <%=$myOperatorKind%> process() mutating.", IP_FILTER);
}

// Tuple processing for non-mutating ports
void MY_OPERATOR::process(Tuple const & tuple, uint32_t port) {
    SPLAPPTRC(L_TRACE, "entering <%=$myOperatorKind%> process() non-mutating.", IP_FILTER);

	if(port == 0) {
    	const IPort0Type& iport$0 = tuple;
		 
        bool ipAddrMatch = false;
		{
			AutoPortMutex amR(mutex_[ip4ListRSel_], *this); // TODO review & comment on locking 
			ipAddrMatch = lookupIPv4(<%=$inputIPAttrParamCppValue%>);
		}
			
	    SPLAPPTRC(L_TRACE, "Process non-mutating. ipAddrMatch: " << ipAddrMatch, IP_FILTER);
        if(ipAddrMatch) {	
            <% CodeGenX::copyOutputAttributesFromInputAttributes("outTuple", $model->getOutputPortAt(0), $model->getInputPortAt(0)); %> ;
            <% CodeGenX::assignOutputAttributeValues("outTuple", $model->getOutputPortAt(0)); %> ;
            SPLAPPTRC(L_TRACE, "submitting outTuple=" << outTuple, IP_FILTER);
            submit(outTuple, 0);
        }

        // Check if a new IP list has been completely built and is now available.
        if(newListAvail) {
            // Take both the R & W mutexes so we can close out the current file
            // and swap lists atomically.
            AutoPortMutex amR(mutex_[ip4ListWSel_], *this);
			AutoPortMutex amW(mutex_[ip4ListRSel_], *this);
            submit(Punctuation::WindowMarker, 0);

            uint32_t tmpList = ip4ListWSel_;
            ip4ListWSel_ = ip4ListRSel_;
            ip4ListRSel_ = tmpList;

            newListAvail = false;
        }
	}
	<% if(defined $inputPort1) {%>
	else if(port == 1) {
		const IPort1Type& iport$1 = tuple;
    	streams_boost::filesystem::path filePath(<%=$inputPort1CppName%>.get_<%=$filenameAttribute%>());
		
        SPLAPPTRC(L_ERROR, "Process non-mutating, port 1.  filePath = " << filePath, IP_FILTER);

        AutoPortMutex amW(mutex_[ip4ListWSel_], *this);
        parseIPFile(filePath.string());
        return;
	}
	<%}%>
}

// Punctuation processing
void MY_OPERATOR::process(Punctuation const & punct, uint32_t port) {
    /*
      if(punct==Punctuation::WindowMarker) {
        // ...;
      } else if(punct==Punctuation::FinalMarker) {
        // ...;
      }
    */
}

/*
 * This method takes in a filename, reads it, parses the content for IPv4 addresses,
 * and inserts them into a set containing all addresses to filter through the operator.
 *
 * There are two set data structures maintained so that one can be used while the other
 * is concurrently updated.  Once the new set is ready, we atomically swap to it.
 *
 * This method  must be called under a mutex to ensure the set is updated by a single
 * thread and that the set toggle is updated correctly.
 */
void MY_OPERATOR::parseIPFile(rstring filename) {
	rstring absPath = convertToAbsolutePath(filename);
	SPLAPPTRC(L_ERROR, "Parsing " << " IP file: " << filename, IP_FILTER);
	
	// parse file and store in list
	ifstream ipFile;
	ipFile.open(absPath.c_str());
	std::string line;
 
    newListAvail = false; 
    ip4List_[ip4ListWSel_]->clear();

	while(std::getline(ipFile, line)) {
        const SPL::rstring ipv4Addr = (SPL::rstring)line;
        SPL::list<SPL::uint32> addrList = getAllAddressesInNetworkInt(ipv4Addr);
        SPL::list<SPL::uint32>::const_iterator it;
        for(it = addrList.begin(); it != addrList.end(); ++it) {
            ip4List_[ip4ListWSel_]->insert(*it);
            SPLAPPTRC(L_ERROR, "IPv4 filter: " << line << ", adding: " << 
                                convertIPV4AddressNumericToString(*it) << 
                                "(" << *it << ")", IP_FILTER);
        }
	}

    newListAvail = true; 
	
	SPLAPPTRC(L_ERROR, "IPv4 list size = " << ip4List_[ip4ListWSel_]->size(), IP_FILTER);

    ipFile.close(); 
}

rstring MY_OPERATOR::convertToAbsolutePath(rstring filename) {
	// Check file path
	streams_boost::filesystem::path absPath(filename);
	if(!absPath.is_absolute()) {
		absPath = getPE().getDataDirectory();
		absPath /= filename.string();
	}
	string pathName = absPath.string();
	
	if(!streams_boost::filesystem::exists(pathName)) {
		// TODO - fix error handling
		string const msg = "File does not exist: " + pathName;
		SPLAPPLOG(L_ERROR, NETWORK_FILE_NOT_FOUND(pathName), IP_FILTER);
		throw new SPLRuntimeException("parseLocationFile", msg);
	}
	
	return pathName;	
}

bool inline MY_OPERATOR::lookupIPv4(const SPL::list<uint32> &numIPList) {
    bool addrMatch = false;

    SPL::list<SPL::uint32>::const_iterator it;
    for(it = numIPList.begin(); it != numIPList.end(); ++it) {
        addrMatch = lookupIPv4(*it); 
        if(addrMatch) return (addrMatch);
    }

    return addrMatch;
}

bool inline MY_OPERATOR::lookupIPv4(const uint32 &numIP) {
    size_t keyCount = ip4List_[ip4ListRSel_]->count(numIP); 

    if(keyCount) {
        return true; 
    } else {
        return false; 
    }
}

<%SPL::CodeGen::implementationEpilogue($model);%>

