/* Additional includes go here */
 
#include<iostream>
#include<sstream> 

#define RTP_EXTRACT_OPER "RtpExtract"

<%SPL::CodeGen::implementationPrologue($model);%>

// Constructor
MY_OPERATOR::MY_OPERATOR()
{	
    // Setup custom metrics
    OperatorMetrics  & opm = getContext().getMetrics();
    numPacketsDropped = & opm.createCustomMetric("totalMalformedPacketsDropped", "Gives the total number of malformed packets that have been dropped.", Metric::Gauge);
    numPacketsDropped -> setValue(0);
}

// Destructor
MY_OPERATOR::~MY_OPERATOR() 
{
    // Finalization code goes here
    
    //free(samples_data);    
}

// Notify port readiness
void MY_OPERATOR::allPortsReady() 
{
    // Notifies that all ports are ready. No tuples should be submitted before
    // this. Source operators can use this method to spawn threads.

    /*
      createThreads(1); // Create source thread
    */
}
 
// Notify pending shutdown
void MY_OPERATOR::prepareToShutdown() 
{
    // This is an asynchronous call
}

// Processing for source and threaded operators   
void MY_OPERATOR::process(uint32_t idx)
{
    // A typical implementation will loop until shutdown
    /*
      while(!getPE().getShutdownRequested()) {
          // do work ...
      }
    */
}

rtp_packet RTPGetRTPPacket(const unsigned char *rtppacket, long pktlen) {
	rtp_packet the_packet;

	/* If packet is encrypted, then the extra 32-bit header used
	 for encryption should have already been stripped off */
	the_packet.RTP_header = (rtp_hdr_t*) rtppacket;
	the_packet.RTP_header->seq = __bswap_16(the_packet.RTP_header->seq);
	the_packet.RTP_header->ts = __bswap_32(the_packet.RTP_header->ts);
	the_packet.RTP_header->ssrc = __bswap_32(the_packet.RTP_header->ssrc);


	if (RTP_X(*the_packet.RTP_header) == 1) { /* Is there an extension? */ 
   
		SPLAPPTRC(L_TRACE,"Extension found.", RTP_EXTRACT_OPER); 

		/* if so, then set up RTP_extension field. */
		the_packet.RTP_extension = (rtp_hdr_ext*) ((char*) rtppacket
				+ sizeof(rtp_hdr_t) + (RTP_CC(*the_packet.RTP_header) - 1) * 4);

		/* Note that if the packet has not yet been converted to host-byte-
		 ordering, then the extension length will be wrong, and so
		 the packet payload will point to the wrong place. */

		the_packet.payload = ((unsigned char*) the_packet.RTP_extension
				+ (the_packet.RTP_extension->elen + 1) * 4);
	}

	/* Otherwise, set extension field to NULL */
	else {
		the_packet.RTP_extension = NULL;
		the_packet.payload = ((unsigned char*) rtppacket + sizeof(rtp_hdr_t)
				+ (RTP_CC(*the_packet.RTP_header) - 1) * 4);
	}
	the_packet.payload_len = pktlen + (long) (rtppacket - the_packet.payload);


	if (RTP_P(*the_packet.RTP_header) == 1) {
	    SPLAPPTRC(L_TRACE,"Padding found.", RTP_EXTRACT_OPER); 
	    /* There is padding on this packet.  The # of bytes of padding
		 (stored in the last byte of the packet = where we currently
		 point to as the last byte in the payload) must be subtracted
		 from our current payload estimate. */
   
		// jms this is gotta be wron
	    SPLAPPTRC(L_TRACE,"Payload length after: " << the_packet.payload_len , RTP_EXTRACT_OPER); 
		if (the_packet.payload_len > 0){
			the_packet.payload_len -= (int) the_packet.payload[the_packet.payload_len - 1];
		} else {
			// the packet hasn't been handled correctly
		}
	}

	return the_packet;
}

unsigned int MY_OPERATOR::getSSRC(rtp_packet the_packet){
    return the_packet.RTP_header->ssrc;
}

unsigned int MY_OPERATOR::getRtpTimestamp(rtp_packet the_packet){
    return the_packet.RTP_header->ts;
}

unsigned int MY_OPERATOR::getRtpSeq(rtp_packet the_packet){
    return the_packet.RTP_header->seq;
}

unsigned int MY_OPERATOR::getRtpPayloadLength(rtp_packet the_packet){
    return the_packet.payload_len;
}

SPL::blob MY_OPERATOR::getRtpPayload(rtp_packet the_packet){
    return blob(the_packet.payload, the_packet.payload_len);
}

// Tuple processing for mutating ports 
void MY_OPERATOR::process(Tuple & tuple, uint32_t port)
{
	<% 
	my $inputPort = $model->getInputPortAt(0);
	my $inputTuple = $inputPort->getCppTupleName();
	%>
	IPort0Type const & <%=$inputTuple%> = static_cast<IPort0Type const&> (tuple); 

//	  int dstPort = <%=$inputTuple%>.get_dstPort();
    const unsigned char *packet = <%=$inputTuple%>.get_netflowMessage().getData();
    int actualSize = <%=$inputTuple%>.get_netflowMessage().getSize(); 
    int payloadLength = <%=$inputTuple%>.get_payloadLength();

    // Extract RTP payload
    rtp_packet the_packet = RTPGetRTPPacket(packet, payloadLength);
    if (the_packet.payload_len <= 0){
    	// we haven't handled it correctly. May not actually be RTP? 
    	static int droppedPacketCount = 0; 
    	droppedPacketCount++;
    	SPLAPPTRC(L_ERROR, "Dropping malformed packet number " << droppedPacketCount << " IpSrc Address: " << <%=$inputTuple%>.get_ipSrc_addr(), RTP_EXTRACT_OPER);
    	numPacketsDropped -> incrementValue(1); 
    	return; 
    }
 
    OPort0Type otuple; 

    // Forward Tuples we have chosen
    <% 
      my $oport = $model->getOutputPortAt(0); 
      foreach my $attribute (@{$oport->getAttributes()}) { 
        my $name = $attribute->getName(); 
        my $operation = $attribute->getAssignmentOutputFunctionName();  
       
        if ($operation eq "AsIs") { 
        	
          my $init = $attribute->getAssignmentOutputFunctionParameterValueAt(0)->getCppExpression();%> 
          otuple.set_<%=$name%>(<%=$init%>); 
         <%} else { %>
          	  otuple.set_<%=$name%>( 
          	  MY_OPERATOR::<%=$operation%>(the_packet)); 
        <%}     
      }%> 
    
    
    submit(otuple, 0); // submit to output port 0        	    

}

// Tuple processing for non-mutating ports
void MY_OPERATOR::process(Tuple const & tuple, uint32_t port)
{
    // Sample submit code
    /* 
      OPort0Type otuple;
      submit(otuple, 0); // submit to output port 0
    */
}

// Punctuation processing
void MY_OPERATOR::process(Punctuation const & punct, uint32_t port)
{
    /*
      if(punct==Punctuation::WindowMarker) {
        // ...;
      } else if(punct==Punctuation::FinalMarker) {
        // ...;
      }
    */
}

<%SPL::CodeGen::implementationEpilogue($model);%>

